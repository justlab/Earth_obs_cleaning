---
title: "Running `Earth_obs_cleaning` on MCD19A2: Results from CONUS"
header-includes:
  - \usepackage{float}
  - \floatplacement{figure}{H}  #make every figure with caption = h, this was the fix
  - \usepackage{helvet} \renewcommand\familydefault{\sfdefault}
output_format:
  pdf_document: default
  html_document: default
always_allow_html: true
bibliography: references.json
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding,
  output_dir = "output", output_format = "all") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = here::here())
```

```{r basics, echo=FALSE}
suppressPackageStartupMessages(
  {library(targets)
    library(Just.universal)
    library(data.table)
    library(DT)
    library(patchwork)
    library(ggplot2)
    library(ggridges)
    library(ggpointdensity)
    library(sf)
    library(Just.universal)
    library(knitr)
    library(kableExtra)
    library(RColorBrewer)
    library(SHAPforxgboost)
    # library(flextable)
  })
# set_flextable_defaults(fonts_ignore=TRUE)
source(here::here("code/functions.R"))
source(here::here("code/paper_functions.R"))
the.sat = tools::toTitleCase(Wf$satellite)
```

```{r git_check, echo=FALSE}
{
s = function(cmd) suppressWarnings(system(cmd,
    intern = TRUE, ignore.stderr = TRUE))
commit = substr(s('git rev-parse HEAD'), 1, 8)
uncommitted = ''
if (!length(commit))
   commit = 'unknown'
else if(length(s('git diff-index HEAD --'))>0)
   uncommitted = 'with uncommitted changes'
}
```

Git commit: `r commit` `r uncommitted`

Rendered: `r Sys.time()`

## Objective

Evaluate the performance of the `Earth_obs_cleaning` software tool on MAIAC MCD19A2 for `r the.sat` across the Continental USA, 2000-2021

# Introduction

# Methods

We used a copy of the AERONET observations that was last modified `r lubridate::as_date(lubridate::with_tz(tz = "UTC", file.mtime(tar_read(aer_orig_obs_path))))`.

# Results

## Main findings from cross-validation

```{r table_cv_results, echo=FALSE}
kbl(pretty.table.numbers(tar_read(cv_summary_table)[1, -"Year"]), align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(1:12, width = "1.1cm")
```

Here **raw** is MCD19A2.V006 MAIAC AOD 470nm; **ground** is AERONET AOD interpolated to 470nm; and **corrected** is MAIAC after applying an XGBoost modeled correction factor.


## Descriptives for the collocated dataset (`r the.sat`)

```{r stratified, echo=FALSE}
dt <- copy(tar_read(initial_cv)$mDT_wPred)
```

While our ultimate goal is to improve AOD, our dependent variable for predictive modeling is the difference of the AOD retrieval and the AERONET AOD which is a nicely symmetric and reasonably well-behaved distribution (an estimate of the retrieval error).

```{r describe_dv, echo=FALSE, eval=TRUE}
kable(summary(dt[, list(y.diff)]))
```

```{r plot_dv, echo=FALSE, eval=TRUE}
ggplot(dt, aes(x = y.diff)) +
  geom_histogram(binwidth = 0.005) +
  scale_x_continuous("MAIAC AOD minus AERONET AOD") +
  coord_cartesian(xlim = c(-1, 1)) +
  labs(title = paste0("Histogram of difference in colocated AOD (n=",
                      dt[, .N], ")"),
      caption = paste0("Not shown: ", dt[y.diff < -1 | y.diff > 1, .N], " AOD differences outside [-1, 1]")) +
  theme_bw()
```

*More still to be added*

## Stratified results for `r the.sat` CV dataset

Here we show our performance metrics in different subsets of the cross-validation results. These are all from the same model training, just slicing up how the performance looks in different contexts.

### Performance by year

```{r strata_year, echo=FALSE, eval=TRUE}
kbl(pretty.table.numbers(tar_read(cv_summary_table)[-1]),
    align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(1:13, width = "1.1cm")
```

We expect more 2021 data to show up over time since Level 2.0 data are often quite late to be added to the AERONET datasets. The 2020 results (higher SD in AERONET, fewer sites, RMSE for MAIAC is higher) are a bit of an anomaly, but also, COVID could have impacted field campaigns and regular recalibration, etc. If we want to look at 2020 specifically, we may want to consider restricting to long-running sites.

### Performance by month of year

```{r strata_month, echo=FALSE}
result <- dt[,
    keyby = .(Month = month(lubridate::as_datetime(time.sat))),
    eval(performance.j)]
result[, Month := month.abb[Month]]
kbl(pretty.table.numbers(result), align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(1:13, width = "1.1cm")
```

```{r plot_by_month, echo=FALSE, eval=TRUE, dev='png', dpi=300}
# Color by quantiles
dt[, month := factor(month(time.sat),
                     labels = month.abb)]
p1 <- ggplot(dt, aes(x = y.diff, y = month, fill = factor(stat(quantile)))) +
  stat_density_ridges(
    geom = "density_ridges_gradient", calc_ecdf = TRUE,
    quantiles = 4, quantile_lines = FALSE
  ) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey90") +
  scale_fill_brewer(name = "Quartiles", type = "div") +
  scale_x_continuous("MAIAC AOD minus AERONET AOD", expand = c(0, 0)) +
  coord_cartesian(xlim = c(-0.25, 0.25)) +
  labs(title = paste0("Histogram of difference in colocated AOD (n=",
                      dt[, .N], ")"),
      caption = paste0("Not shown: ", dt[y.diff < -0.25 | y.diff > 0.25, .N], " AOD differences outside [-0.25, 0.25]")) +
  theme_bw()
suppressMessages(print(p1))
```

### Performance by `qa_best`

```{r strata_qa, echo=FALSE}
kbl(pretty.table.numbers(dt[, eval(performance.j), by = qa_best]),
    align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(1:13, width = "1.1cm")
```

The takeaway here is that even though the RMSE of MAIAC is substantially better for `qa_best` versus non-best pixels, the improvements in the predicted AOD make even the non-best pixels have lower RMSE than the raw MAIAC `qa_best` and in that sense, we are expanding the set of high quality data by correcting for biases related to QA flagging criteria.

### Performance for higher versus lower AOD (AERONET > 0.6)

```{r strata_high_aod, echo=FALSE, fig.pos="H"}
kbl(pretty.table.numbers(dt[, eval(performance.j), by = .(aod_high = y.ground > 0.6)]),
    align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(2:13, width = "1.1cm")
```

### Performance by number of overpasses in collocation that site-day

```{r strata_overpasses, echo=FALSE, fig.pos="H"}
dt[, overpasses := .N, by = .(site, lubridate::as_date(time.ground))]
kbl(pretty.table.numbers(dt[, eval(performance.j), keyby = overpasses]),
    align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(2:13, width = "1.1cm")
```

### Performance by NOAA climate regions

```{r noaa_setup, echo=FALSE}
noaa.regions = list(
  # https://www.ncdc.noaa.gov/monitoring-references/maps/us-climate-regions.php
    Ohio.Valley = c("IL", "IN", "KY", "MO", "OH", "TN", "WV"), #previously 'Central'
    Upper.Midwest = c("IA", "MI", "MN", "WI"), #previously 'East.North.Central'
    Northeast = c("DC", "CT", "DE", "ME", "MD", "MA", "NH", "NJ", "NY", "PA", "RI", "VT"),
      # Washington, DC, has no assigned NOAA climate region, so treat
      # it as part of Maryland.
    Northwest = c("ID", "OR", "WA"),
    South = c("AR", "KS", "LA", "MS", "OK", "TX"),
    Southeast = c("AL", "FL", "GA", "NC", "SC", "VA"),
    Southwest = c("AZ", "CO", "NM", "UT"),
    West = c("CA", "NV"),
    Northern.Rockies.and.Plains = c("MT", "NE", "ND", "SD", "WY")) #previously 'West.North.Central'

state.abb.plusdc = c(state.abb, "DC")
conus.states.plusdc = sort(setdiff(state.abb.plusdc, c("AK", "HI")))

stopifnot(identical(
    sort(unlist(noaa.regions, use.names = F)),
    conus.states.plusdc))

state.noaa.region = factor(
   sapply(state.abb.plusdc, USE.NAMES = F,
       function(sa) if (sa %in% c("AK", "HI")) NA else
           names(noaa.regions)[which(sapply(noaa.regions, function(r)
               sa %in% r))]),
   levels = names(noaa.regions))

# Contiguous US state boundaries
# will replace with a region defined by Kodi later
conus = st_transform(crs = crs.us.atlas, get_conus())
```

```{r get_noaa_regions, include=FALSE}
# assign AERONET stations to states
tar_load(aer_stations)
aer_stations_sf <- st_transform(crs = st_crs(conus), st_as_sf(aer_stations, coords = c("lon", "lat"), crs = "epsg:4326"))
aer_stations_sf <- st_join(aer_stations_sf, conus)
colnames(aer_stations_sf)[colnames(aer_stations_sf) == "Site_Name"] = "site"
dt <- merge(dt, aer_stations_sf[, c("site", "STUSPS")], by = "site")
# some sites don't fall within land polygons for whatever reason
dt[is.na(STUSPS), table(site)]
# where are the sites that didn't fall within a state?
site_nostate <- st_as_sf(dt[is.na(STUSPS), ][unique(site), .(site, geometry), mult = "first"])
# ggplot() +
#   geom_sf(data = conus, fill = NA) +
#   geom_sf(data = site_nostate, color = "red")
# what proportion of data are not in a state?
dt[, proportions(table(is.na(STUSPS)))]
# assign these to the closest state
matched <- st_join(site_nostate,
                   conus,
                   join=nngeo::st_nn, k=1)
# plot these matchups
# ggplot() +
#   geom_sf(data = conus, fill = NA) +
#   geom_sf_text(data = matched, aes(label = STUSPS), color = "red") + theme_minimal()
dt[as.data.table(matched, key = "site"), STUSPS := i.STUSPS]

# where do our data come from (by State)?
dt[, .(uniqueN(site), .N), by = STUSPS][order(N, decreasing = T)]

# assign NOAA region from state USPS codes
dt[, state.noaa.region := factor(
   sapply(STUSPS, USE.NAMES = F,
       function(sa) if (sa %in% c("AK", "HI")) NA else
           names(noaa.regions)[which(sapply(noaa.regions, function(r)
               sa %in% r))]),
   levels = names(noaa.regions))]
```

```{r strata_noaa_regions, echo=FALSE, fig.pos="H"}
# performance by NOAA climate regions
by.region = dt[, eval(performance.j), keyby = state.noaa.region]
kbl(pretty.table.numbers(by.region),
    align = "l") %>%
  kable_styling(position = "left",
                latex_options=c("HOLD_position","scale_down")) %>%
  row_spec(0,bold=TRUE) %>% column_spec(2:13, width = "1.1cm")
```

```{r noaa_region_plot, echo=FALSE, dev='png', dpi=300}
## map of performance by NOAA regions
conus$state.noaa.region <- factor(
   sapply(conus$STUSPS, USE.NAMES = F,
       function(sa) if (sa %in% c("AK", "HI")) NA else
           names(noaa.regions)[which(sapply(noaa.regions, function(r)
               sa %in% r))]),
   levels = names(noaa.regions))
conus <- merge(conus, by.region, by = "state.noaa.region")
conus_melt <- melt(as.data.table(conus[, c("geometry", "state.noaa.region", "RMSE, raw", "RMSE, corrected")]),
                   id.vars = c("geometry", "state.noaa.region"))
levels(conus_melt$variable) <- c("MAIAC AOD", "corrected AOD")
map_region_rmse <- ggplot(conus_melt, aes(geometry = geometry)) +
  geom_sf(aes(fill = value)) +
  geom_sf(data = dt[, .(.N, geometry = geometry[1]), by = site], aes(geometry = geometry, size = N), alpha = 0.1) +
  facet_wrap(~variable, ncol = 1) +
  coord_sf(default_crs = st_crs(conus)) +
  scale_size("colocated\nobservations", range = c(1, 3)) +
  scale_fill_continuous("Regional\nRMSE") +
  theme_minimal() +
  theme(axis.text = element_blank(),
        panel.grid.major = element_blank())
map_region_rmse
```

## Agreement Plots

```{r error_envelope, echo=TRUE}
# error envelope for MAIAC is equivalent to that reported in AMT MAIAC publication
dt[, round(100 * proportions(table(y.sat > (y.ground - 0.05 - 0.1*y.ground) & y.sat < (y.ground + 0.05 + 0.1*y.ground))))]
# sure looks like we would have a much smaller error envelope (in both additive and multiplicative terms)
dt[, round(100 * proportions(table(y.ground.pred > (y.ground - 0.025 - 0.055*y.ground) & y.ground.pred < (y.ground + 0.025 + 0.055*y.ground))))]

# now with our error envelope function
envelope.sat <- empirical.error.envelope(dt, pred = "y.sat") 
head(envelope.sat)

# and for the corrected data
envelope.ground.pred <- empirical.error.envelope(dt, pred = "y.ground.pred") 
head(envelope.ground.pred)
```

```{r agreement_plot, echo=FALSE, dev='png', dpi=300}
p1 <- ggplot(dt[y.ground < 1 & y.sat < 1]) +
  aes(y.ground, y.sat) +
  geom_pointdensity(alpha = 0.1, size = 0.6) +
  geom_abline(linetype = "dashed") +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
  scale_x_continuous("AERONET AOD 470nm", limits = c(0, 1), expand = c(0, 0)) +
  scale_y_continuous("MAIAC AOD 470nm", limits = c(0, 1), expand = c(0, 0)) +
  guides(color = "none") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  labs(caption = paste0("Not shown: ", dt[y.ground > 1 | y.sat > 1, .N], " AOD values outside [0, 1]"))


p2  <- ggplot(dt[y.ground < 1 & y.ground.pred > 0 & y.ground.pred < 1]) +
  aes(y.ground, y.ground.pred) +
  geom_pointdensity(alpha = 0.1, size = 0.6) +
  geom_abline(linetype = "dashed") +
  geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
  scale_x_continuous("AERONET AOD 470nm", limits = c(0, 1), expand = c(0, 0)) +
  scale_y_continuous("MAIAC AOD 470nm", limits = c(0, 1), expand = c(0, 0)) +
  guides(color = "none") +
  theme_bw() +
  theme(aspect.ratio = 1) +
  labs(caption = paste0("Not shown: ", dt[y.ground > 1 | y.ground.pred > 1 | y.ground.pred < 0, .N], " AOD values outside [0, 1]"))

p1 + p2
```

## SHAP interpretation

In decreasing order of variable importance (from `r the.sat` collocated cross-validation predictions)

```{r shap_rank, echo=FALSE}
# what do the SHAPs tell us?
tar_load(initial_cv)
shaps <- initial_cv$"shap_score"
# sort by importance
df_shap <- data.frame(meanabsshap = round(sort(sapply(abs(shaps), mean), decreasing = TRUE), 4))
kbl(df_shap, col.names = "Mean |SHAP|") %>% row_spec(0, bold=TRUE)
# df_shap$variable <- row.names(df_shap)
# ft_shap <- flextable(df_shap[, c(2, 1)])
# ft_shap <- set_header_labels(ft_shap, list(variable = "Variable", meanabsshap = "Mean Absolute SHAP"))
# ft_shap
```
Summary visualization of SHAP contributions

```{r shap_summary, echo=FALSE, dev='png', dpi=300, eval=FALSE}
shap_long <- shap.prep(shap_contrib = initial_cv$shap_score,
                       X_train = initial_cv$mDT_wPred[, names(initial_cv_l2$shap_score), with = F])
# **SHAP summary plot**
shap.plot.summary(shap_long)
```

```{r shap_features, echo=FALSE, dev='png', dpi=300, eval=FALSE}
g1 <- shap.plot.dependence(data_long = shap_long, x = 'time.sat', y = 'Column_WV', color_feature = 'Column_WV') + ggtitle("(A) SHAP values of Column WV vs. Time trend")
# g2 <- shap.plot.dependence(data_long = shap_long, x = 'time.sat', y = 'y.sat', color_feature = 'y.sat') +  ggtitle("(B) SHAP values of MAIAC AOD vs. Time trend")
#
# gridExtra::grid.arrange(g1, g2, ncol = 2)
g1
```

## Maps of new predictions

### Median MSE day

```{r pred.map.median.mse, echo = F}
pred.map(
    tar_read(T.median.mse.map.data)$pred, tar_read(pred_grid),
    bg.sf = get_conus(), color.scale.name = "AOD",
    limits = list(lon = c(-107, Inf), lat = c(-Inf, 37)),
    quantile.cap = .99)
```

This map shows a tile on `r tar_read(T.median.mse.map.data)$date`.

### Baltimore

```{r pred.map.balitmore, echo = F}
pred.map(
    tar_read(T.baltimore.map.data), tar_read(pred_grid),
    bg.sf = get_conus(), color.scale.name = "AOD")
```

*End of report*
